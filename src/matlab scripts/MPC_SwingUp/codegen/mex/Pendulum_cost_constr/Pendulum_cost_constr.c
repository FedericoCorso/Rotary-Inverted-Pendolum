/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * Pendulum_cost_constr.c
 *
 * Code generation for function 'Pendulum_cost_constr'
 *
 */

/* Include files */
#include "Pendulum_cost_constr.h"
#include "Pendulum_cost_constr_data.h"
#include "rt_nonfinite.h"
#include "blas.h"
#include "mwmathutil.h"
#include <stddef.h>
#include <string.h>

/* Variable Definitions */
static emlrtECInfo emlrtECI = {
    -1,                     /* nDims */
    25,                     /* lineNo */
    5,                      /* colNo */
    "Pendulum_cost_constr", /* fName */
    "/Users/federicocorso/Library/CloudStorage/OneDrive-PolitecnicodiMilano/"
    "Automation Lab/Rotary-Inverted-Pendolum/src/matlab script"
    "s/MPC_SwingUp/Pendulum_cost_constr.m" /* pName */
};

static emlrtECInfo b_emlrtECI = {
    -1,                     /* nDims */
    22,                     /* lineNo */
    5,                      /* colNo */
    "Pendulum_cost_constr", /* fName */
    "/Users/federicocorso/Library/CloudStorage/OneDrive-PolitecnicodiMilano/"
    "Automation Lab/Rotary-Inverted-Pendolum/src/matlab script"
    "s/MPC_SwingUp/Pendulum_cost_constr.m" /* pName */
};

/* Function Definitions */
void Pendulum_cost_constr(const emlrtStack *sp, const real_T U[1500],
                          const real_T z0[4], real_T Ts, const real_T Q[16],
                          real_T R, real_T Qf, real_T usat, real_T xsat,
                          real_T alpha, real_T beta,
                          const real_T parameters[14], real_T *f,
                          real_T zsim[6004])
{
  ptrdiff_t incx_t;
  ptrdiff_t incy_t;
  ptrdiff_t n_t;
  real_T F[13505];
  real_T b_y[1500];
  real_T y[1500];
  real_T ztemp[4];
  real_T b_zdot_idx_3_tmp;
  real_T c_zdot_idx_3_tmp;
  real_T t15;
  real_T t16;
  real_T t16_tmp;
  real_T t18;
  real_T t20;
  real_T t4;
  real_T t5;
  real_T t7;
  real_T t8;
  real_T zdot_idx_3_tmp;
  int32_T b_i;
  int32_T i;
  int32_T ind;
  int32_T k;
  int32_T loop_ub;
  memset(&zsim[0], 0, 6004U * sizeof(real_T));
  zsim[0] = z0[0];
  ztemp[0] = z0[0];
  zsim[1] = z0[1];
  ztemp[1] = z0[1];
  zsim[2] = z0[2];
  ztemp[2] = z0[2];
  zsim[3] = z0[3];
  ztemp[3] = z0[3];
  for (k = 0; k < 1500; k++) {
    zdot_idx_3_tmp = U[k];
    y[k] = muDoubleScalarExp(-beta * (usat + zdot_idx_3_tmp));
    b_y[k] = muDoubleScalarExp(-beta * (usat - zdot_idx_3_tmp));
  }
  memset(&F[0], 0, 6000U * sizeof(real_T));
  F[6004] = Qf * U[1499];
  for (i = 0; i < 1500; i++) {
    F[i + 6005] = R * U[i];
    F[i + 7505] = alpha * y[i];
    F[i + 9005] = alpha * b_y[i];
  }
  memset(&F[10505], 0, 3000U * sizeof(real_T));
  t4 = parameters[4] * parameters[4];
  t5 = muDoubleScalarPower(parameters[4], 3.0);
  t7 = parameters[5] * parameters[5];
  t8 = parameters[6] * parameters[6];
  t15 = parameters[2] * parameters[5] * t4;
  t16_tmp = parameters[3] * parameters[5];
  t16 = t16_tmp * t4;
  t20 = t4 * t7 * t8;
  t18 = t4 * t4 * t7;
  b_zdot_idx_3_tmp = parameters[0] * parameters[5];
  c_zdot_idx_3_tmp = b_zdot_idx_3_tmp * t4;
  for (ind = 0; ind < 1500; ind++) {
    real_T b_Q[4];
    real_T t10;
    real_T t11;
    real_T t13;
    real_T t14;
    real_T t2;
    real_T t21;
    real_T t27;
    real_T t3;
    real_T tau;
    real_T zdot_idx_2_tmp;
    real_T zdot_idx_3;
    /*  Update the state */
    /* NL_eqns */
    /*     NL_DIFF_EQNS_SS =
     * NL_eqns(B_p,B_r,J_a,J_p,G,L_P,M_P,R,TAU,x(2,1),x(3,1),x(4,1),X_DOT_1,X_DOT_2,X_DOT_3,X_DOT_4)
     */
    /*     This function was generated by the Symbolic Math Toolbox version 9.2.
     */
    /*     09-Mar-2023 15:34:15 */
    tau = parameters[8] * parameters[10] * parameters[11] * parameters[13] *
          (U[ind] - parameters[8] * parameters[12] * ztemp[2]) / parameters[9];
    /*  motor torque expression-STATIC */
    t2 = muDoubleScalarCos(ztemp[1]);
    t3 = muDoubleScalarSin(ztemp[1]);
    t10 = ztemp[2] * ztemp[2];
    t11 = ztemp[3] * ztemp[3];
    t13 = t2 * t2;
    t14 = muDoubleScalarSin(ztemp[1] * 2.0);
    t21 = t13 * t18;
    t27 = 1.0 /
          ((((((((parameters[2] * parameters[3] + t15) + t16) + t16_tmp * t8) +
               t18) +
              t20) -
             t13 * t16) -
            t21) -
           t13 * t20);
    zdot_idx_2_tmp = parameters[6] * t2 * t5 * t7;
    zdot_idx_3 = t10 * t14;
    zdot_idx_3_tmp = parameters[7] * t3 * t5 * t7;
    zdot_idx_3 =
        t27 *
        (((((((((((((((parameters[0] * parameters[2] * ztemp[3] * 2.0 -
                       zdot_idx_3 * t15) -
                      zdot_idx_3 * t18) -
                     zdot_idx_3 * t20) +
                    zdot_idx_3 * t21) -
                   zdot_idx_3_tmp * 2.0) +
                  t2 * t3 * t11 * t20 * 2.0) +
                 c_zdot_idx_3_tmp * ztemp[3] * 2.0) +
                b_zdot_idx_3_tmp * t8 * ztemp[3] * 2.0) -
               parameters[2] * parameters[7] * parameters[4] * parameters[5] *
                   t3 * 2.0) -
              c_zdot_idx_3_tmp * t13 * ztemp[3] * 2.0) -
             parameters[4] * parameters[7] * t3 * t7 * t8 * 2.0) -
            parameters[4] * parameters[5] * parameters[6] * t2 * tau * 2.0) +
           zdot_idx_3_tmp * t13 * 2.0) +
          parameters[1] * parameters[4] * parameters[5] * parameters[6] * t2 *
              ztemp[2] * 2.0) +
         zdot_idx_2_tmp * t14 * ztemp[2] * ztemp[3] * 2.0) *
        -0.5;
    ztemp[0] += Ts * ztemp[2];
    zdot_idx_3_tmp = ztemp[1] + Ts * ztemp[3];
    ztemp[1] = zdot_idx_3_tmp;
    t21 = ztemp[2] +
          Ts * (t27 *
                ((((((((((parameters[3] * tau * -2.0 +
                          parameters[1] * parameters[3] * ztemp[2] * 2.0) -
                         parameters[5] * t4 * tau * 2.0) +
                        t14 * t16 * ztemp[2] * ztemp[3] * 2.0) +
                       t14 * t18 * ztemp[2] * ztemp[3] * 2.0) +
                      parameters[1] * parameters[5] * t4 * ztemp[2] * 2.0) +
                     parameters[6] * t3 * t5 * t7 * t11 * 2.0) -
                    parameters[6] * parameters[7] * t2 * t3 * t4 * t7 * 2.0) -
                   zdot_idx_2_tmp * t10 * t14) +
                  parameters[0] * parameters[4] * parameters[5] *
                      parameters[6] * t2 * ztemp[3] * 2.0) +
                 parameters[3] * parameters[4] * parameters[5] * parameters[6] *
                     t3 * t11 * 2.0) *
                -0.5);
    ztemp[2] = t21;
    t13 = ztemp[3] + Ts * zdot_idx_3;
    ztemp[3] = t13;
    k = (ind + 1) << 2;
    b_i = (ind + 2) << 2;
    if (k + 1 > b_i) {
      i = 0;
      b_i = 0;
    } else {
      i = k;
    }
    loop_ub = b_i - i;
    b_i = 4;
    emlrtSubAssignSizeCheckR2012b(&loop_ub, 1, &b_i, 1, &b_emlrtECI,
                                  (emlrtCTX)sp);
    for (b_i = 0; b_i < loop_ub; b_i++) {
      zsim[i + b_i] = ztemp[b_i];
    }
    /*  Update the cost function */
    i = ind << 2;
    if (i + 1 > k) {
      i = 0;
      b_i = 0;
    } else {
      b_i = k;
    }
    loop_ub = b_i - i;
    b_i = 4;
    emlrtSubAssignSizeCheckR2012b(&loop_ub, 1, &b_i, 1, &emlrtECI,
                                  (emlrtCTX)sp);
    zdot_idx_3 = muDoubleScalarSin(zdot_idx_3_tmp / 2.0);
    for (b_i = 0; b_i < 4; b_i++) {
      b_Q[b_i] = ((Q[b_i] * t21 + Q[b_i + 4] * zdot_idx_3) + Q[b_i + 8] * t21) +
                 Q[b_i + 12] * t13;
    }
    for (b_i = 0; b_i < loop_ub; b_i++) {
      F[i + b_i] = b_Q[b_i];
    }
    zdot_idx_3_tmp = zsim[k];
    F[ind + 10505] = alpha * muDoubleScalarExp(-beta * (xsat + zdot_idx_3_tmp));
    F[ind + 12005] = alpha * muDoubleScalarExp(-beta * (xsat - zdot_idx_3_tmp));
    if (*emlrtBreakCheckR2012bFlagVar != 0) {
      emlrtBreakCheckR2012b((emlrtConstCTX)sp);
    }
  }
  /*  Update the terminal cost */
  F[6000] = Qf * zsim[6000];
  F[6001] = Qf * muDoubleScalarSin(zsim[6002] / 2.0);
  F[6002] = Qf * zsim[6001];
  F[6003] = Qf * zsim[6003];
  n_t = (ptrdiff_t)13505;
  incx_t = (ptrdiff_t)1;
  incy_t = (ptrdiff_t)1;
  *f = ddot(&n_t, &F[0], &incx_t, &F[0], &incy_t);
}

/* End of code generation (Pendulum_cost_constr.c) */
